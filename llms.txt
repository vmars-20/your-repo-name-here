# forge-vhdl: AI-Powered VHDL Development Template

**GitHub template for VHDL development with Claude Code - optimized for LLM-assisted workflows**

## Quick Reference

**What:** Production-ready GitHub template with reusable VHDL components + token-efficient CocoTB tests
**Where:** Works everywhere - Claude Code Web, GitHub Codespaces, local CLI (auto-detects!)
**Setup:** Zero config in cloud â€¢ `brew install ghdl` for local â€¢ Env detection: `uv run python .claude/env_detect.py`
**Test:** CocoTB + GHDL filter (P1 tests <20 lines, 98% noise reduction vs 287 lines)
**Workflow:** Hybrid recommended - Requirements locally â†’ Agents in cloud â†’ Integrate locally
**Template:** Clone from https://github.com/vmars-20/forge-vhdl-3v3-vmars â†’ Customize your copy!

## Structure

```
vhdl/
â”œâ”€â”€ packages/       # Voltage utilities, serialization, common types
â”‚   â”œâ”€â”€ forge_voltage_*_pkg          # Direct voltage utilities (3v3, 5v0, 5v_bipolar)
â”‚   â”œâ”€â”€ forge_serialization_*_pkg    # Register serialization (types, voltage, time)
â”‚   â”œâ”€â”€ forge_common_pkg             # FORGE_READY control scheme
â”‚   â””â”€â”€ forge_lut_pkg                # Look-up table utilities
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ utilities/      # forge_util_clk_divider, threshold trigger
â”‚   â”œâ”€â”€ debugging/      # forge_hierarchical_encoder, fsm_observer
â”‚   â””â”€â”€ loader/         # forge_bram_loader (BRAM initialization)

cocotb_tests/       # VHDL simulation tests (CocoTB + GHDL)
python_tests/       # Python unit tests (pytest for Python utilities)
scripts/            # ghdl_output_filter.py, cloud_setup_with_ghdl.py
docs/               # Testing standards, guides, patterns
```

## Key Components (With CocoTB Tests)

**forge_util_clk_divider** - Programmable clock divider
- P1 tests: 3 (reset, divide-by-2, enable)
- Output: ~20 lines, ~50 tokens

**forge_lut_pkg** - Look-up table utilities
- P1 tests: 4 (constants, conversions, index, boundary)
- Output: ~15 lines, ~70 tokens

**forge_voltage_3v3_pkg** - 0-3.3V voltage domain (TTL/digital logic)
- P1 tests: 4 (to_digital, from_digital, is_valid, clamp)
- Output: ~9 lines

**forge_voltage_5v0_pkg** - 0-5.0V voltage domain (unipolar supply)
- P1 tests: 4 (same as above)
- Output: ~9 lines

**forge_voltage_5v_bipolar_pkg** - Â±5.0V voltage domain (Moku DAC/ADC)
- P1 tests: 4 (same as above)
- Output: ~9 lines

**Design:** Function-based type safety, Verilog compatible, explicit domain selection
**Details:** See CLAUDE.md "Voltage Type System (Phase 4)" section for complete design rationale

**forge_serialization_types_pkg** - Core serialization type utilities (NEW!)
- Boolean â†” std_logic conversions (`bool_to_sl`, `sl_to_bool`)
- Register bit type (`std_logic_reg_from_raw`, `std_logic_reg_to_raw`) - identity functions
- Use with: forge_serialization_voltage_pkg, forge_serialization_time_pkg

**forge_serialization_voltage_pkg** - Voltage register serialization (NEW!)
- Converts voltage values â†” register bits
- Available ranges: Â±0.5V, Â±5V, Â±20V, Â±25V (16-bit/8-bit, signed/unsigned variants)
- New in v1.1: Â±5V types (`voltage_input_5v_bipolar_s16`, `voltage_output_5v_bipolar_s16`)
- Use for: Control register communication with Moku DAC/ADC

**forge_serialization_time_pkg** - Time register serialization (NEW!)
- Converts time durations â†” clock cycles
- Clock-frequency aware functions
- Use for: Timing control via registers

**forge_common_pkg** - FORGE_READY control scheme (NEW! from BPD)
- CR0[31:29] safe initialization handshaking
- BRAM loader protocol constants
- combine_forge_ready() function
- Production-proven architecture pattern

**fsm_observer** - Export FSM state to Moku registers (no tests yet)
**forge_bram_loader** - BRAM initialization (no tests yet)

## AI Agent Toolkit (NEW!)

**forge-vhdl includes specialized agents for autonomous VHDL development:**

### Development Workflow

**Requirements Gathering** â†’ **0. New Component Planner** â†’ **1. Component Generator** â†’ **2. Test Designer** â†’ **3. Test Runner**

**AI-First Requirements** (`workflow/AI_FIRST_REQUIREMENTS.md`) â­ **DEFAULT for Students/Beginners**
- **Purpose:** Rapid spec generation via pattern recognition and intelligent defaults
- **Time:** 2-5 minutes (vs 15-30 min for Engineer workflow)
- **Process:** Pattern matching + 2-3 critical questions only
- **Output:** Complete component specification in `workflow/specs/pending/`
- **Features:** Fast iteration, intelligent inference, pattern-based defaults
- **Best for:** Students, beginners, clear requirements, pattern-matched components
- **Usage:** "I need a [component description]. Use the AI-First requirements workflow."

**Engineer Requirements** (`workflow/ENGINEER_REQUIREMENTS.md`) - For Detailed Technical Control
- **Purpose:** Comprehensive requirements gathering through 7-phase Q&A
- **Time:** 15-30 minutes (thorough, detailed)
- **Process:** 30 questions across 7 phases (identification, functionality, interface, behavior, testing, design, generation)
- **Output:** Complete component specification in `workflow/specs/pending/`
- **Features:** Standards validation, guided questions, educational, full control
- **Best for:** Engineers, novel architectures, complex systems, learning standards in depth
- **Usage:** "I want to create a new VHDL component. Please read workflow/ENGINEER_REQUIREMENTS.md and guide me through the requirements process."

**Step 0: forge-new-component** (`.claude/agents/forge-new-component/agent.md`)
- **Purpose:** File structure scaffolding from specifications
- **Modes:** Placeholder generation from specs
- **Outputs:** Markdown placeholder files (.vhd.md, .py.md) with specifications
- **Next:** Hand off to Component Generator + Test Designer (parallel)
- **Usage:** Converts specs into placeholder files for agent workflow.

**Step 1: forge-vhdl-component-generator** (`.claude/forge-vhdl-component-generator.md`)
- **Purpose:** VHDL-2008 code generation with GHDL simulation awareness
- **Modes:** Pure VHDL, FORGE-aware, component usage, CocoTB tests
- **Inputs:** Requirements (from forge-new-component placeholder or direct spec)
- **Outputs:** VHDL component entity/architecture
- **Next:** Hand off to Test Designer

**Step 2: cocotb-progressive-test-designer** (`.claude/agents/cocotb-progressive-test-designer/`)
- **Purpose:** Design P1/P2/P3 test architectures
- **Inputs:** VHDL component from Component Generator + placeholders from forge-new-component
- **Outputs:** Test strategy, expected values, test wrappers, constants file design
- **Next:** Hand off to Test Runner

**Step 3: cocotb-progressive-test-runner** (`.claude/agents/cocotb-progressive-test-runner/`)
- **Purpose:** Implement and execute CocoTB tests
- **Inputs:** Test architecture from Test Designer + placeholders from forge-new-component
- **Outputs:** Working test suite, execution results
- **Next:** Complete or iterate with Test Designer

**Each agent is aware of its role in the workflow and references neighbors.**

### Quick Start Pattern

**For brand new components (DEFAULT - Students/Beginners):**

**ðŸ”„ HYBRID WORKFLOW (RECOMMENDED for Local CLI users):**
1. **Local:** Run `/forge-start` â†’ Choose Student (AI-First) workflow
2. **Local:** Answer 2-3 questions â†’ Spec generated in `workflow/specs/pending/`
3. **Local:** Commit spec: `git add workflow/specs/pending/ && git commit && git push`
4. **Cloud:** Open Claude Web â†’ Attach repository â†’ Say: "Read workflow/specs/pending/[component].md and execute 3-agent workflow"
5. **Cloud:** Agents run autonomously (VHDL generation â†’ Test design â†’ Test execution with incremental commits)
6. **Local:** Pull results: `git pull`
7. **Local:** Integrate: `mv workflow/artifacts/vhdl/[component].vhd vhdl/components/[category]/`

**ðŸ’¡ Example workflow:** See `claude` branch for complete agent execution example!
- `git fetch origin claude && git log origin/claude --oneline` - View incremental commits
- `git diff main...origin/claude` - See generated artifacts

**Why hybrid?**
- Local CLI: Fast interactive requirements (output settings control)
- Claude Web: Unlimited agent execution (no token limits, auto GHDL setup, incremental commits)
- Local CLI: Final review and integration (familiar tooling)

**Cloud-only workflow (Claude Web or Codespaces):**
1. **AI-First requirements** - Ask Claude: "I need a [component description]. Use the AI-First requirements workflow."
2. **Spec proposed** - Claude proposes complete spec after 2-3 critical questions
3. **Review/refine** - Approve or refine defaults
4. **Automated workflow** - Run 3-agent workflow on spec â†’ Generates VHDL + tests
5. **Review artifacts** - Check `workflow/artifacts/vhdl/` and `workflow/artifacts/tests/`
6. **Integrate** - Move to main codebase when satisfied

**For complex/novel components (Engineers):**
1. **Engineer requirements** - Ask Claude: "I want to create a new VHDL component. Please read workflow/ENGINEER_REQUIREMENTS.md and guide me through the requirements process."
2. **Spec created** - Claude generates `workflow/specs/pending/component.md` after 7-phase Q&A
3. **Automated workflow** - Run 3-agent workflow on spec â†’ Generates VHDL + tests
4. **Review artifacts** - Check `workflow/artifacts/vhdl/` and `workflow/artifacts/tests/`
5. **Integrate** - Move to main codebase when satisfied

**Using reference patterns (fast learning):**
- 6 gold-standard specs in `workflow/specs/reference/`:
  - `edge_detector.md` - Simple utility (registered comparison)
  - `synchronizer.md` - CDC metastability mitigation (multi-stage registers)
  - `pwm_generator.md` - Counter-based pattern
  - `debouncer.md` - FSM pattern with timing
  - `pulse_stretcher.md` - Retriggerable timing pattern
  - `forge_util_edge_detector.md` - AI-First workflow example output â† NEW
- Browse these to understand spec format and quality standards
- Run workflow: "Read workflow/specs/reference/edge_detector.md and execute the complete 3-agent workflow"

**For direct implementation (requirements crystal clear):**
1. **forge-vhdl-component-generator** - Direct spec â†’ Creates .vhd
2. **cocotb-progressive-test-designer** - Analyzes .vhl â†’ Designs tests
3. **cocotb-progressive-test-runner** - Implements tests

## Testing

### VHDL Simulation Tests (CocoTB + GHDL)

**Purpose:** Test VHDL components via simulation

```bash
# Run P1 tests (LLM-optimized, <20 lines)
uv run python cocotb_tests/run.py forge_util_clk_divider

# Run P2 tests (full validation)
TEST_LEVEL=P2_INTERMEDIATE uv run python cocotb_tests/run.py forge_util_clk_divider

# List all VHDL tests
uv run python cocotb_tests/run.py --list
```

### Python Unit Tests (pytest)

**Purpose:** Test Python utilities (HVS decoder, GHDL filter, etc.)

```bash
# Run all Python unit tests
pytest python_tests/

# Run with coverage
pytest python_tests/ --cov=python/
```

**CRITICAL DISTINCTION:**
- `cocotb_tests/` = VHDL simulation (CocoTB runner, GHDL simulator)
- `python_tests/` = Python unit tests (pytest runner, no VHDL)

## Integration Pattern

**This is a GitHub template repository!**

**To use:**
1. Click "Use this template" â†’ Create your own repository
2. Clone your repository: `git clone https://github.com/YOUR-USERNAME/YOUR-REPO-NAME`
3. Update README.md with your repository URL (lines 47, 51, 500)
4. Start building components!

**Can also be used as a git submodule:**
```bash
git submodule add https://github.com/YOUR-USERNAME/YOUR-REPO-NAME.git libs/forge-vhdl
```

VHDL files compiled with GHDL via CocoTB test infrastructure.

## Cloud Setup (Recommended - Works Everywhere!)

**ðŸŒ One-command setup for Claude Code Web, GitHub Codespaces, or any container:**

```bash
uv run python scripts/cloud_setup_with_ghdl.py
```

**What it does:**
- âœ… Auto-installs GHDL + LLVM 18 (Ubuntu/Debian containers)
- âœ… Creates LLVM library symlink (critical for GHDL-LLVM)
- âœ… Sets up Python virtual environment with UV
- âœ… Installs all packages in editable mode
- âœ… Runs validation test to confirm VHDL simulation works
- â±ï¸ Complete setup in ~2-3 minutes

**Result:** Full VHDL development environment in your browser!

**Detailed guide:** `docs/CLOUD_SETUP_PROMPT.md`

**DevContainer:** Repository includes `.devcontainer/devcontainer.json` for automatic setup in GitHub Codespaces or VS Code Remote Containers.

## Local Development (Pre-installed GHDL)

```bash
# If you already have GHDL installed
uv sync                                  # Install dependencies
uv run python cocotb_tests/run.py --all # Run all VHDL tests (P1)
```

**Install GHDL first:**
- Ubuntu/Debian: `sudo apt-get install ghdl ghdl-llvm`
- macOS: `brew install ghdl`

## Testing Quick Start

### VHDL Simulation Tests (CocoTB)

```bash
# Run P1 tests (default, LLM-optimized, <20 lines output)
uv run python cocotb_tests/run.py forge_util_clk_divider

# Run P2 tests (comprehensive validation)
TEST_LEVEL=P2_INTERMEDIATE uv run python cocotb_tests/run.py forge_util_clk_divider

# Run with more verbosity
COCOTB_VERBOSITY=NORMAL uv run python cocotb_tests/run.py forge_util_clk_divider

# List all available VHDL tests
uv run python cocotb_tests/run.py --list

# Run all VHDL tests (P1)
uv run python cocotb_tests/run.py --all
```

### Python Unit Tests (pytest)

```bash
# Run all Python unit tests
pytest python_tests/

# Run specific test file
pytest python_tests/test_hierarchical_decoder.py
```

## Documentation Hierarchy

**Three-tier documentation system optimized for token efficiency:**

**Tier 1 (Quick Ref):** This file (llms.txt) - ~800 tokens
- Component catalog
- Basic usage examples
- Pointers to Tier 2

**Tier 2 (Authoritative):** CLAUDE.md - ~3.5k tokens
- Complete testing standards
- CocoTB progressive testing guide
- Critical interface rules (real/boolean type constraints)
- VHDL coding standards summary
- Component integration patterns
- Quick reference appendix

**Tier 3 (Specialized):** Load only when needed
- `docs/VHDL_CODING_STANDARDS.md` - Complete style guide (rarely loaded)
- `docs/COCOTB_TROUBLESHOOTING.md` - Problemâ†’Solution debugging
- `scripts/GHDL_FILTER.md` - Filter implementation details

**Workflow Documentation:**
- `workflow/specs/README.md` - Specification writing guide (3-tier structure)
- `workflow/specs/reference/README.md` - Gold-standard pattern library (5 specs)
- `workflow/specs/pending/README.md` - Active work queue
- `workflow/specs/completed/README.md` - Implementation archive
- `workflow/INTERACTIVE_REQUIREMENTS.md` - Conversational requirements gathering guide
- `workflow/README.md` - Complete workflow guide

**Navigation pattern:**
- Quick question? â†’ Read llms.txt (this file)
- Design/testing question? â†’ Read CLAUDE.md
- Workflow question? â†’ Read workflow/README.md
- Specific error/deep dive? â†’ Read Tier 3 docs
- Example workflow? â†’ Check `claude` branch (git fetch origin claude)

---

**Version:** 3.2.0 (template-ready, environment-aware)
**Original Template:** https://github.com/vmars-20/forge-vhdl-3v3-vmars
**License:** MIT
**Type:** Standalone GitHub template (clone and customize!)
**Example Workflow:** See `claude` branch for complete 3-agent execution example
